
BB_output_file <- "BB multivariate log reg and cox reg output.txt"
sink(BB_output_file)



#first model:
multilogreg.fit <- glm(formula = Readmission ~ gender + AgeGrouped + ethnicity_grouped + type + bmi_status + consults 
                       + COPD + CVD + heart_failure + CKD + T1DM + T2DM + cerebrovasc_disease + stroke_hx 
                       + depression + anxiety + insomnia + polypharmacy + antipsych_meds + med_reviews 
                       + residential_care + e2015_imd_5, data=dementia_data, family=binomial(link="logit"))
summary(multilogreg.fit)



#Multicollinearity check of first model
library(car)
vif_values <- vif(multilogreg.fit)
print(vif_values)



#AIC-based model selection
#backward elimination
multi_aic_back <- step(multilogreg.fit, trace=0, direction="backward")
summary(multi_aic_back)

#forward elimination
fitted_null <- glm(formula = Readmission ~ 1, data=dementia_data, family=binomial(link="logit"))
multi_aic_forward <- step(fitted_null, scope=list(lower=fitted_null, upper=multilogreg.fit), trace=0, direction="forward")
summary(multi_aic_forward)

#forward and backward elimination combined
multi_aic_both <- step(multilogreg.fit, scope=list(lower=fitted_null, upper=multilogreg.fit), trace=0, direction="both")
summary(multi_aic_both)

#final model based on these (lowest AIC number: all models have same number so chose both - can choose any.)
final_log_reg <-glm(formula = Readmission ~ gender + AgeGrouped + ethnicity_grouped + consults + COPD + CVD + heart_failure 
                    + CKD + T1DM + T2DM + cerebrovasc_disease + stroke_hx + depression + antipsych_meds + med_reviews 
                    + residential_care + e2015_imd_5, data=dementia_data, family=binomial(link="logit")) 
summary(final_log_reg)


#functions to get ORs and 95%CIs from LR models
oddsratio <- function(x) {exp(coef(x))}
oddsratioci <- function(x) {exp(confint(x))}

#get OR and 95%CIs of  model
cbind(oddsratio(final_log_reg), oddsratioci(final_log_reg))



#check vif of final model
vif_values_final <- vif(final_log_reg)
print(vif_values_final)

#covariates pattern - how many unique covariate combinations in the dataset
design_matrix <- model.matrix(final_log_reg)
covariates_pattern <- unique.matrix(design_matrix)
nrow(covariates_pattern)  #appropriate result for sample size, makes model stable with also handling multicollinearity with VIF




#Hosmer-Lemeshow test (goodness of fit)
library(blorr)
blr_test_hosmer_lemeshow(final_log_reg)

#AUC
library(pROC)

#get predicted probabilities of model
predicted_probs <- predict(final_log_reg, type = "response")

#calculate the ROC curve and AUC
roc_curve <- roc(dementia_data$Readmission, predicted_probs)

#get the AUC value
auc_value <- auc(roc_curve)
print(auc_value)


#plot ROC curve
gains_table <- blr_gains_table(final_log_reg)
blr_roc_curve(gains_table)






dev.off() #resets graphics device if graphs not showing



#MODEL 1a: bmi missing data removed

multilogreg2.fit<- glm(Readmission ~ gender + AgeGrouped + ethnicity_grouped + type + bmi_status + consults
                       + COPD + CVD + heart_failure + CKD + T1DM + T2DM + cerebrovasc_disease + stroke_hx + depression
                       + anxiety + insomnia + polypharmacy + antipsych_meds + med_reviews + residential_care
                       + e2015_imd_5, data=dementia_data2, family=binomial(link="logit"))

summary(multilogreg2.fit)

#check VIF values
vif_values2 <- vif(multilogreg2.fit)
print(vif_values2)


#AIC-based model selection
#backward elimination
multi_aic_back2 <- step(multilogreg2.fit, trace=0, direction="backward")
summary(multi_aic_back2)

#forward selection
fitted_null2 <- glm(formula = Readmission ~ 1, data=dementia_data2, family=binomial(link="logit"))
multi_aic_forward2 <- step(fitted_null2, scope=list(lower=fitted_null2, upper=multilogreg2.fit), trace=0, direction="forward")
summary(multi_aic_forward2)

#forward and backward combined
multi_aic_both2 <- step(multilogreg2.fit, scope=list(lower=fitted_null2, upper=multilogreg2.fit), trace=0, direction="both")
summary(multi_aic_both2)

#final model based on these (lowest AIC number: all models have same number so chose both - can choose any.)
final_logreg2 <-glm(formula = Readmission ~ gender + AgeGrouped + ethnicity_grouped + type + consults + COPD + CVD 
                    + heart_failure + CKD + T1DM + T2DM + stroke_hx + depression + antipsych_meds + med_reviews 
                    + residential_care, data=dementia_data2, family=binomial(link="logit")) 
summary(final_logreg2)




#get OR and 95%CIs of  model
cbind(oddsratio(final_logreg2), oddsratioci(final_logreg2))



#check vif of final model
vif_values2 <- vif(final_logreg2)
print(vif_values2)



#covariates pattern - how many unique covariate combinations in the dataset
design_matrix2 <- model.matrix(final_logreg2)
covariates_pattern2 <- unique.matrix(design_matrix2)
nrow(covariates_pattern2)  #appropriate result for sample size, makes model stable with also handling multicollinearity with VIF



#Hosmer-Lemeshow test (goodness of fit)
blr_test_hosmer_lemeshow(final_logreg2) #generally good fit, observed outcomes not sig different to predicted outcomes (models predicted probs align well with the actual data)

#AUC
#get predicted probabilities of model
predicted_probs2 <- predict(final_logreg2, type = "response")

#calculate the ROC curve and AUC
roc_curve2 <- roc(dementia_data2$Readmission, predicted_probs2)

#get the AUC value
auc_value2 <- auc(roc_curve2)
print(auc_value2)


#plot ROC curve
gains_table2 <- blr_gains_table(final_logreg2)
blr_roc_curve(gains_table2)




#bmi wasn't retained in either final model, therefore choose MODEL 1 as main model



#MODEL 2
multilogreg3.fit<- glm(formula = Readmission ~ gender + AgeGrouped + ethnicity_grouped + type + bmi_status + consults 
                       + LTC_cat + polypharmacy + antipsych_meds + med_reviews 
                       + residential_care + e2015_imd_5, data=dementia_data, family=binomial(link="logit"))

summary(multilogreg3.fit)



#check VIF values
vif_values3 <- vif(multilogreg3.fit)
print(vif_values3)



#AIC-based model selection
#backward elimination
multi_aic_back3 <- step(multilogreg3.fit, trace=0, direction="backward")
summary(multi_aic_back3)

#forward selection
fitted_null3 <- glm(formula = Readmission ~ 1, data=dementia_data, family=binomial(link="logit"))
multi_aic_forward3 <- step(fitted_null3, scope=list(lower=fitted_null3, upper=multilogreg3.fit), trace=0, direction="forward")
summary(multi_aic_forward3)

#forward and backward combined
multi_aic_both3 <- step(multilogreg3.fit, scope=list(lower=fitted_null3, upper=multilogreg3.fit), trace=0, direction="both")
summary(multi_aic_both3)

#final model based on these (lowest AIC number: all models have same number so chose both - can choose any. chose both)
final_logreg3 <-glm(formula = Readmission ~ gender + AgeGrouped + ethnicity_grouped + type + consults
                    + LTC_cat + antipsych_meds + med_reviews + residential_care + e2015_imd_5, data=dementia_data, family=binomial(link="logit"))

summary(final_logreg3)



#get OR and 95%CIs of  model
cbind(oddsratio(final_logreg3), oddsratioci(final_logreg3))


#check vif of final model
vif_values3 <- vif(final_logreg3)
print(vif_values3)


#covariates pattern - how many unique covariate combinations in the dataset
design_matrix3 <- model.matrix(final_logreg3)
covariates_pattern3 <- unique.matrix(design_matrix3)
nrow(covariates_pattern3)  #appropriate result for sample size, makes model stable with also handling multicollinearity with VIF



#Hosmer-Lemeshow test (goodness of fit)
blr_test_hosmer_lemeshow(final_logreg3) #generally good fit, observed outcomes not sig different to predicted outcomes (models predicted probs align well with the actual data)

#AUC
#get predicted probabilities of model
predicted_probs3 <- predict(final_logreg3, type = "response")

#calculate the ROC curve and AUC
roc_curve3 <- roc(dementia_data$Readmission, predicted_probs3)

#get the AUC value
auc_value3 <- auc(roc_curve3)
print(auc_value3)


#plot ROC curve
gains_table3 <- blr_gains_table(final_logreg3)
blr_roc_curve(gains_table3)

#####################################

#MODEL 4: Investigating the risk of death within 1 year of readmission

library(dplyr)
library(lubridate)

#create a dataset containing only cases with rapid readmission to look
#at outcomes relating to death after rapid readmission

dementia_data3 <- dementia_data[!is.na(dementia_data$admidate_1), ]

#Define end of follow up as earliest of death date (dod), tod, lcd, or study end date
dementia_data3 <- dementia_data3 %>%
  mutate(
    end_of_followup = as.Date(pmin(dod, tod, lcd, as.Date("2018-11-30"), na.rm = TRUE))
  )

#Define eligibility for readmission-death group
dementia_data3 <- dementia_data3 %>%
  mutate(
    eligible_readmit = !is.na(admidate_1) & admidate_1 <= end_of_followup
  )


#define 1-year window after readmission
dementia_data3 <- dementia_data3 %>% 
  mutate(
    end_1yr_readm = admidate_1 %m+% lubridate::years(1)
  )


#define event indicator: death within 1 year of readmission
dementia_data3 <- dementia_data3 %>% 
  mutate(
    died_1yr_readm = case_when(
      !eligible_readmit ~ NA_integer_,  #not eligible i.e. end of follow up falls earlier than readmission
        !is.na(dod) & 
        dod >= admidate_1 &           #Death date on or after readmission (eligible group pt1)
        dod <= end_1yr_readm ~ 1L,    #AND died within 1 yr of readm (eligible group pt2)
      TRUE ~ 0L,                      #Pts in this group eligible but death date not in 1yr readm window
    )
  )


#define censoring date (excluding death, this is the event of interest)
dementia_data3 <- dementia_data3 %>% 
  mutate(
    censor_date_1yr = case_when(
      eligible_readmit ~ pmin(
        tod,
        lcd,
        as.Date("2018-11-30"),
        end_1yr_readm,
        na.rm = TRUE
      ),
      TRUE ~ as.Date(NA)
    )
  )



#Define time-to-event variable (days)
dementia_data3 <- dementia_data3 %>% 
  mutate(
    time_to_event = case_when(
      died_1yr_readm == 1 ~ as.numeric(dod - admidate_1),
      died_1yr_readm == 0 ~ as.numeric(censor_date_1yr - admidate_1),
      TRUE ~ NA_real_
    )
  )



#create a censoring indicator
dementia_data3 <- dementia_data3 %>% 
  mutate(
    censored = case_when(
      died_1yr_readm == 0 ~ "censored",
      died_1yr_readm == 1 ~ "died within 1 year",
      TRUE ~ NA_character_
    )
  )


#restrict summary stats to the eligible subgroup
summary_stats <- dementia_data3 %>%
  filter(eligible_readmit) %>% 
  group_by(censored) %>%
  summarise(
    mean_age = mean(index_adm_age, na.rm = TRUE),
    
    prop_female = mean(gender == "Female", na.rm = TRUE),
    
    prop_white = mean(ethnicity_grouped == "White", na.rm = TRUE),
    prop_asian = mean(ethnicity_grouped == "Asian", na.rm = TRUE),
    prop_black = mean(ethnicity_grouped == "Black", na.rm = TRUE),
    prop_other = mean(ethnicity_grouped == "Other", na.rm = TRUE),
    
    prop_alzheimers = mean(type == "Alzheimers", na.rm = TRUE),
    prop_VaD = mean(type == "VaD", na.rm = TRUE),
    prop_DLB = mean(type == "DLB", na.rm = TRUE),
    prop_alcoholic = mean(type == "Alcoholic", na.rm = TRUE),
    prop_mixed = mean(type == "Mixed", na.rm = TRUE),
    prop_unspecified = mean(type == "Unspecified", na.rm = TRUE),
    
    prop_consults = mean(consults == "1", na.rm = TRUE),
    
    prop_LTC0 = mean(LTC_cat == "0", na.rm = TRUE),
    prop_LTC1 = mean(LTC_cat == "1", na.rm = TRUE),
    prop_LTC2_3 = mean(LTC_cat %in% c("2", "3"), na.rm = TRUE),
    prop_LTC4_5 = mean(LTC_cat %in% c("4","5"), na.rm = TRUE),
    prop_LTC6plus = mean(LTC_cat == "6+", na.rm = TRUE),
    
    prop_antipsychs = mean(antipsych_meds == "1", na.rm = TRUE),
    prop_medreviews = mean(med_reviews == "1", na.rm = TRUE),
    prop_res = mean(residential_care == "1", na.rm = TRUE),
    
    total_n = n()
  )


View(summary_stats)


#average time to readmission
dementia_data3 <- dementia_data3 %>%
  mutate(time_to_readmission = as.numeric(admidate_1 - admidate_0))

summary(dementia_data3$time_to_readmission)
sd(dementia_data3$time_to_readmission, na.rm=TRUE)

#how many readm pts died within one year
table(dementia_data3$died_1yr_readm)



#stats for time to death within 1yr readmission
summary(dementia_data3$time_to_event)
hist(dementia_data3$time_to_event)
sd(dementia_data3$time_to_event, na.rm = TRUE)




#Prep for cox regression
library(survival)


#define eligible patients & no missing time_to_events and died_1yr_read values
analysis_df <- dementia_data3 %>%
  filter(eligible_readmit) %>%
  filter(!is.na(time_to_event),
         !is.na(died_1yr_readm)) %>%
  filter(time_to_event >= 0)




table(analysis_df$died_1yr_readm) #check only 0 and 1 fields



#fit full cox model
cox_full <- coxph(Surv(time_to_event, died_1yr_readm) ~ gender + AgeGrouped + ethnicity_grouped + type + bmi_status + consults 
                  + LTC_cat + polypharmacy + antipsych_meds + med_reviews 
                  + residential_care + e2015_imd_5, data = analysis_df)


summary(cox_full)


#fit the null cox model 
cox_null <- coxph(
  Surv(time_to_event, died_1yr_readm) ~ 1,
  data = analysis_df
)


#stepwise selection: backwards elimination
cox_backwards <- step(cox_full, direction = "backward", trace = 0)
summary(cox_backwards)
extractAIC(cox_backwards)


#forward selection
cox_forward <- step(cox_null, scope = list(lower = cox_null, upper = cox_full), direction = "forward", trace = 0)
summary(cox_forward)
extractAIC(cox_forward)


#both directions
cox_both <- step(cox_full, scope = list(lower = cox_null, upper = cox_full), direction = "both", trace = 0)
summary(cox_both)
extractAIC(cox_both)


#fit final model (both)
final_cox <- coxph(formula(cox_both), data = analysis_df)
summary(final_cox)

#Cox regression proportional hazards assumption
ph_test <- cox.zph(final_cox) #test for cox regression assumption that variable HRs remain constant over time
print(ph_test) #results: gender p=0.04, borderline PH assumption violated



ph_test #get global p value "does the PH assumption hold for the model overall?"
        #global p=0.78 (evidence that model is fine overall)

ph <- cox.zph(final_cox)
plot(ph, var = "gender") #plot show mil drift for gender, therefore reasonable to keep in model, no time-varying trend observed







#sensitivity test for informative censoring
#creating censoring indicator for log reg model
d_sub <- analysis_df %>% 
  mutate(
    censored = if_else(died_1yr_readm == 0, 1L, 0L) # 1=censored, 0=died within 1 yr
  )


#fit log reg model - checks whether baseline covariates predict censoring status
censor_full <- glm(censored ~ gender + AgeGrouped + ethnicity_grouped + type + bmi_status + consults 
                   + LTC_cat + polypharmacy + antipsych_meds + med_reviews 
                   + residential_care + e2015_imd_5, data = d_sub, family = binomial(link = "logit"))

summary(censor_full)

vif(censor_full)





#Main cohort person-years
dementia_data <- dementia_data %>%
  mutate(
    end_of_followup = pmin(dod, tod, lcd, as.Date("2018-11-30"), na.rm = TRUE),           #define end of follow up as the earliest death date, transfer-out date, last collection date, or study end date (nov 2018)
    end_of_followup = if_else(is.na(end_of_followup) | end_of_followup < admidate_0,
                              admidate_0, end_of_followup),                              #ensure follow-up does not end before index adm. if so, reset it to index adm date
    person_days = as.numeric(difftime(end_of_followup, admidate_0, units = "days"))         #calc person-yrs from index adm to end of follow up in days
  )

summary(dementia_data$person_days)
sd(dementia_data$person_days, na.rm = TRUE)
sum(dementia_data$person_days, na.rm = TRUE)



#Person-years for readmitted subset
readmit_df <- dementia_data3 %>%
  filter(eligible_readmit) %>%
  mutate(
    end_of_followup = pmin(dod, tod, lcd, as.Date("2018-11-30"), end_1yr_readm, na.rm = TRUE),  
    end_of_followup = if_else(is.na(end_of_followup) | end_of_followup < admidate_1,
                              admidate_1, end_of_followup),                             
    person_days = as.numeric(difftime(end_of_followup, admidate_1, units = "days"))         
  )

summary(readmit_df$person_days)
sd(readmit_df$person_days, na.rm = TRUE)
sum(readmit_df$person_days, na.rm = TRUE)




#Person-years for non-readmitted subset
nonreadmit_df <- dementia_data %>%
  filter(!Readmission) %>%
  mutate(
    end_of_followup = pmin(dod, tod, lcd, as.Date("2018-11-30"), na.rm = TRUE),
    end_of_followup = if_else(is.na(end_of_followup) | end_of_followup < admidate_0,
                              admidate_0, end_of_followup),
    person_days = as.numeric(difftime(end_of_followup, admidate_0, units = "days"))
  )

summary(nonreadmit_df$person_days)
sd(nonreadmit_df$person_days, na.rm = TRUE)

sum(nonreadmit_df$person_days, na.rm = TRUE) 








sink()


